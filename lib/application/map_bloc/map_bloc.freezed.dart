// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'map_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MapEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapEventCopyWith<$Res> {
  factory $MapEventCopyWith(MapEvent value, $Res Function(MapEvent) then) =
      _$MapEventCopyWithImpl<$Res, MapEvent>;
}

/// @nodoc
class _$MapEventCopyWithImpl<$Res, $Val extends MapEvent>
    implements $MapEventCopyWith<$Res> {
  _$MapEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'MapEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements MapEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$LaunchTaxiImplCopyWith<$Res> {
  factory _$$LaunchTaxiImplCopyWith(
          _$LaunchTaxiImpl value, $Res Function(_$LaunchTaxiImpl) then) =
      __$$LaunchTaxiImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Point companyLocation});
}

/// @nodoc
class __$$LaunchTaxiImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$LaunchTaxiImpl>
    implements _$$LaunchTaxiImplCopyWith<$Res> {
  __$$LaunchTaxiImplCopyWithImpl(
      _$LaunchTaxiImpl _value, $Res Function(_$LaunchTaxiImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyLocation = null,
  }) {
    return _then(_$LaunchTaxiImpl(
      null == companyLocation
          ? _value.companyLocation
          : companyLocation // ignore: cast_nullable_to_non_nullable
              as Point,
    ));
  }
}

/// @nodoc

class _$LaunchTaxiImpl implements _LaunchTaxi {
  const _$LaunchTaxiImpl(this.companyLocation);

  @override
  final Point companyLocation;

  @override
  String toString() {
    return 'MapEvent.launchYandexTaxi(companyLocation: $companyLocation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LaunchTaxiImpl &&
            (identical(other.companyLocation, companyLocation) ||
                other.companyLocation == companyLocation));
  }

  @override
  int get hashCode => Object.hash(runtimeType, companyLocation);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LaunchTaxiImplCopyWith<_$LaunchTaxiImpl> get copyWith =>
      __$$LaunchTaxiImplCopyWithImpl<_$LaunchTaxiImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return launchYandexTaxi(companyLocation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return launchYandexTaxi?.call(companyLocation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (launchYandexTaxi != null) {
      return launchYandexTaxi(companyLocation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return launchYandexTaxi(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return launchYandexTaxi?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (launchYandexTaxi != null) {
      return launchYandexTaxi(this);
    }
    return orElse();
  }
}

abstract class _LaunchTaxi implements MapEvent {
  const factory _LaunchTaxi(final Point companyLocation) = _$LaunchTaxiImpl;

  Point get companyLocation;

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LaunchTaxiImplCopyWith<_$LaunchTaxiImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CheckPermissionImplCopyWith<$Res> {
  factory _$$CheckPermissionImplCopyWith(_$CheckPermissionImpl value,
          $Res Function(_$CheckPermissionImpl) then) =
      __$$CheckPermissionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckPermissionImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$CheckPermissionImpl>
    implements _$$CheckPermissionImplCopyWith<$Res> {
  __$$CheckPermissionImplCopyWithImpl(
      _$CheckPermissionImpl _value, $Res Function(_$CheckPermissionImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CheckPermissionImpl implements _CheckPermission {
  const _$CheckPermissionImpl();

  @override
  String toString() {
    return 'MapEvent.checkLocationPermission()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CheckPermissionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return checkLocationPermission();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return checkLocationPermission?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (checkLocationPermission != null) {
      return checkLocationPermission();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return checkLocationPermission(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return checkLocationPermission?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (checkLocationPermission != null) {
      return checkLocationPermission(this);
    }
    return orElse();
  }
}

abstract class _CheckPermission implements MapEvent {
  const factory _CheckPermission() = _$CheckPermissionImpl;
}

/// @nodoc
abstract class _$$MakeSingleRouteImplCopyWith<$Res> {
  factory _$$MakeSingleRouteImplCopyWith(_$MakeSingleRouteImpl value,
          $Res Function(_$MakeSingleRouteImpl) then) =
      __$$MakeSingleRouteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Point endLocation});
}

/// @nodoc
class __$$MakeSingleRouteImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$MakeSingleRouteImpl>
    implements _$$MakeSingleRouteImplCopyWith<$Res> {
  __$$MakeSingleRouteImplCopyWithImpl(
      _$MakeSingleRouteImpl _value, $Res Function(_$MakeSingleRouteImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? endLocation = null,
  }) {
    return _then(_$MakeSingleRouteImpl(
      null == endLocation
          ? _value.endLocation
          : endLocation // ignore: cast_nullable_to_non_nullable
              as Point,
    ));
  }
}

/// @nodoc

class _$MakeSingleRouteImpl implements _MakeSingleRoute {
  const _$MakeSingleRouteImpl(this.endLocation);

  @override
  final Point endLocation;

  @override
  String toString() {
    return 'MapEvent.makeSingleRoute(endLocation: $endLocation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MakeSingleRouteImpl &&
            (identical(other.endLocation, endLocation) ||
                other.endLocation == endLocation));
  }

  @override
  int get hashCode => Object.hash(runtimeType, endLocation);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MakeSingleRouteImplCopyWith<_$MakeSingleRouteImpl> get copyWith =>
      __$$MakeSingleRouteImplCopyWithImpl<_$MakeSingleRouteImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return makeSingleRoute(endLocation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return makeSingleRoute?.call(endLocation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (makeSingleRoute != null) {
      return makeSingleRoute(endLocation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return makeSingleRoute(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return makeSingleRoute?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (makeSingleRoute != null) {
      return makeSingleRoute(this);
    }
    return orElse();
  }
}

abstract class _MakeSingleRoute implements MapEvent {
  const factory _MakeSingleRoute(final Point endLocation) =
      _$MakeSingleRouteImpl;

  Point get endLocation;

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MakeSingleRouteImplCopyWith<_$MakeSingleRouteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MakeMainRouteImplCopyWith<$Res> {
  factory _$$MakeMainRouteImplCopyWith(
          _$MakeMainRouteImpl value, $Res Function(_$MakeMainRouteImpl) then) =
      __$$MakeMainRouteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Point endLocation});
}

/// @nodoc
class __$$MakeMainRouteImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$MakeMainRouteImpl>
    implements _$$MakeMainRouteImplCopyWith<$Res> {
  __$$MakeMainRouteImplCopyWithImpl(
      _$MakeMainRouteImpl _value, $Res Function(_$MakeMainRouteImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? endLocation = null,
  }) {
    return _then(_$MakeMainRouteImpl(
      null == endLocation
          ? _value.endLocation
          : endLocation // ignore: cast_nullable_to_non_nullable
              as Point,
    ));
  }
}

/// @nodoc

class _$MakeMainRouteImpl implements _MakeMainRoute {
  const _$MakeMainRouteImpl(this.endLocation);

  @override
  final Point endLocation;

  @override
  String toString() {
    return 'MapEvent.makeMainRoute(endLocation: $endLocation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MakeMainRouteImpl &&
            (identical(other.endLocation, endLocation) ||
                other.endLocation == endLocation));
  }

  @override
  int get hashCode => Object.hash(runtimeType, endLocation);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MakeMainRouteImplCopyWith<_$MakeMainRouteImpl> get copyWith =>
      __$$MakeMainRouteImplCopyWithImpl<_$MakeMainRouteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return makeMainRoute(endLocation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return makeMainRoute?.call(endLocation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (makeMainRoute != null) {
      return makeMainRoute(endLocation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return makeMainRoute(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return makeMainRoute?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (makeMainRoute != null) {
      return makeMainRoute(this);
    }
    return orElse();
  }
}

abstract class _MakeMainRoute implements MapEvent {
  const factory _MakeMainRoute(final Point endLocation) = _$MakeMainRouteImpl;

  Point get endLocation;

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MakeMainRouteImplCopyWith<_$MakeMainRouteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CalculateDistanceImplCopyWith<$Res> {
  factory _$$CalculateDistanceImplCopyWith(_$CalculateDistanceImpl value,
          $Res Function(_$CalculateDistanceImpl) then) =
      __$$CalculateDistanceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Point start, Point end});
}

/// @nodoc
class __$$CalculateDistanceImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$CalculateDistanceImpl>
    implements _$$CalculateDistanceImplCopyWith<$Res> {
  __$$CalculateDistanceImplCopyWithImpl(_$CalculateDistanceImpl _value,
      $Res Function(_$CalculateDistanceImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? start = null,
    Object? end = null,
  }) {
    return _then(_$CalculateDistanceImpl(
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as Point,
      end: null == end
          ? _value.end
          : end // ignore: cast_nullable_to_non_nullable
              as Point,
    ));
  }
}

/// @nodoc

class _$CalculateDistanceImpl implements _CalculateDistance {
  const _$CalculateDistanceImpl({required this.start, required this.end});

  @override
  final Point start;
  @override
  final Point end;

  @override
  String toString() {
    return 'MapEvent.calculateDistance(start: $start, end: $end)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalculateDistanceImpl &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.end, end) || other.end == end));
  }

  @override
  int get hashCode => Object.hash(runtimeType, start, end);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CalculateDistanceImplCopyWith<_$CalculateDistanceImpl> get copyWith =>
      __$$CalculateDistanceImplCopyWithImpl<_$CalculateDistanceImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return calculateDistance(start, end);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return calculateDistance?.call(start, end);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (calculateDistance != null) {
      return calculateDistance(start, end);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return calculateDistance(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return calculateDistance?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (calculateDistance != null) {
      return calculateDistance(this);
    }
    return orElse();
  }
}

abstract class _CalculateDistance implements MapEvent {
  const factory _CalculateDistance(
      {required final Point start,
      required final Point end}) = _$CalculateDistanceImpl;

  Point get start;
  Point get end;

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CalculateDistanceImplCopyWith<_$CalculateDistanceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetUserLocationImplCopyWith<$Res> {
  factory _$$GetUserLocationImplCopyWith(_$GetUserLocationImpl value,
          $Res Function(_$GetUserLocationImpl) then) =
      __$$GetUserLocationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetUserLocationImplCopyWithImpl<$Res>
    extends _$MapEventCopyWithImpl<$Res, _$GetUserLocationImpl>
    implements _$$GetUserLocationImplCopyWith<$Res> {
  __$$GetUserLocationImplCopyWithImpl(
      _$GetUserLocationImpl _value, $Res Function(_$GetUserLocationImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetUserLocationImpl implements _GetUserLocation {
  const _$GetUserLocationImpl();

  @override
  String toString() {
    return 'MapEvent.getUserLocation()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetUserLocationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(Point companyLocation) launchYandexTaxi,
    required TResult Function() checkLocationPermission,
    required TResult Function(Point endLocation) makeSingleRoute,
    required TResult Function(Point endLocation) makeMainRoute,
    required TResult Function(Point start, Point end) calculateDistance,
    required TResult Function() getUserLocation,
  }) {
    return getUserLocation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(Point companyLocation)? launchYandexTaxi,
    TResult? Function()? checkLocationPermission,
    TResult? Function(Point endLocation)? makeSingleRoute,
    TResult? Function(Point endLocation)? makeMainRoute,
    TResult? Function(Point start, Point end)? calculateDistance,
    TResult? Function()? getUserLocation,
  }) {
    return getUserLocation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(Point companyLocation)? launchYandexTaxi,
    TResult Function()? checkLocationPermission,
    TResult Function(Point endLocation)? makeSingleRoute,
    TResult Function(Point endLocation)? makeMainRoute,
    TResult Function(Point start, Point end)? calculateDistance,
    TResult Function()? getUserLocation,
    required TResult orElse(),
  }) {
    if (getUserLocation != null) {
      return getUserLocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_LaunchTaxi value) launchYandexTaxi,
    required TResult Function(_CheckPermission value) checkLocationPermission,
    required TResult Function(_MakeSingleRoute value) makeSingleRoute,
    required TResult Function(_MakeMainRoute value) makeMainRoute,
    required TResult Function(_CalculateDistance value) calculateDistance,
    required TResult Function(_GetUserLocation value) getUserLocation,
  }) {
    return getUserLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult? Function(_CheckPermission value)? checkLocationPermission,
    TResult? Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult? Function(_MakeMainRoute value)? makeMainRoute,
    TResult? Function(_CalculateDistance value)? calculateDistance,
    TResult? Function(_GetUserLocation value)? getUserLocation,
  }) {
    return getUserLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_LaunchTaxi value)? launchYandexTaxi,
    TResult Function(_CheckPermission value)? checkLocationPermission,
    TResult Function(_MakeSingleRoute value)? makeSingleRoute,
    TResult Function(_MakeMainRoute value)? makeMainRoute,
    TResult Function(_CalculateDistance value)? calculateDistance,
    TResult Function(_GetUserLocation value)? getUserLocation,
    required TResult orElse(),
  }) {
    if (getUserLocation != null) {
      return getUserLocation(this);
    }
    return orElse();
  }
}

abstract class _GetUserLocation implements MapEvent {
  const factory _GetUserLocation() = _$GetUserLocationImpl;
}

/// @nodoc
mixin _$MapState {
  FormzSubmissionStatus get getLocationStatus =>
      throw _privateConstructorUsedError;
  LocationPermission get permissionStatus => throw _privateConstructorUsedError;
  List<MapObject> get singleMapObjects => throw _privateConstructorUsedError;
  List<MapObject> get mainMapObjects => throw _privateConstructorUsedError;
  double get distanceInKm => throw _privateConstructorUsedError;
  String get travelTime => throw _privateConstructorUsedError;
  bool get hasLocationPermission => throw _privateConstructorUsedError;
  Point? get userLocation => throw _privateConstructorUsedError;
  String get errorMessage => throw _privateConstructorUsedError;

  /// Create a copy of MapState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MapStateCopyWith<MapState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapStateCopyWith<$Res> {
  factory $MapStateCopyWith(MapState value, $Res Function(MapState) then) =
      _$MapStateCopyWithImpl<$Res, MapState>;
  @useResult
  $Res call(
      {FormzSubmissionStatus getLocationStatus,
      LocationPermission permissionStatus,
      List<MapObject> singleMapObjects,
      List<MapObject> mainMapObjects,
      double distanceInKm,
      String travelTime,
      bool hasLocationPermission,
      Point? userLocation,
      String errorMessage});
}

/// @nodoc
class _$MapStateCopyWithImpl<$Res, $Val extends MapState>
    implements $MapStateCopyWith<$Res> {
  _$MapStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MapState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? getLocationStatus = null,
    Object? permissionStatus = null,
    Object? singleMapObjects = null,
    Object? mainMapObjects = null,
    Object? distanceInKm = null,
    Object? travelTime = null,
    Object? hasLocationPermission = null,
    Object? userLocation = freezed,
    Object? errorMessage = null,
  }) {
    return _then(_value.copyWith(
      getLocationStatus: null == getLocationStatus
          ? _value.getLocationStatus
          : getLocationStatus // ignore: cast_nullable_to_non_nullable
              as FormzSubmissionStatus,
      permissionStatus: null == permissionStatus
          ? _value.permissionStatus
          : permissionStatus // ignore: cast_nullable_to_non_nullable
              as LocationPermission,
      singleMapObjects: null == singleMapObjects
          ? _value.singleMapObjects
          : singleMapObjects // ignore: cast_nullable_to_non_nullable
              as List<MapObject>,
      mainMapObjects: null == mainMapObjects
          ? _value.mainMapObjects
          : mainMapObjects // ignore: cast_nullable_to_non_nullable
              as List<MapObject>,
      distanceInKm: null == distanceInKm
          ? _value.distanceInKm
          : distanceInKm // ignore: cast_nullable_to_non_nullable
              as double,
      travelTime: null == travelTime
          ? _value.travelTime
          : travelTime // ignore: cast_nullable_to_non_nullable
              as String,
      hasLocationPermission: null == hasLocationPermission
          ? _value.hasLocationPermission
          : hasLocationPermission // ignore: cast_nullable_to_non_nullable
              as bool,
      userLocation: freezed == userLocation
          ? _value.userLocation
          : userLocation // ignore: cast_nullable_to_non_nullable
              as Point?,
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MapStateImplCopyWith<$Res>
    implements $MapStateCopyWith<$Res> {
  factory _$$MapStateImplCopyWith(
          _$MapStateImpl value, $Res Function(_$MapStateImpl) then) =
      __$$MapStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FormzSubmissionStatus getLocationStatus,
      LocationPermission permissionStatus,
      List<MapObject> singleMapObjects,
      List<MapObject> mainMapObjects,
      double distanceInKm,
      String travelTime,
      bool hasLocationPermission,
      Point? userLocation,
      String errorMessage});
}

/// @nodoc
class __$$MapStateImplCopyWithImpl<$Res>
    extends _$MapStateCopyWithImpl<$Res, _$MapStateImpl>
    implements _$$MapStateImplCopyWith<$Res> {
  __$$MapStateImplCopyWithImpl(
      _$MapStateImpl _value, $Res Function(_$MapStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of MapState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? getLocationStatus = null,
    Object? permissionStatus = null,
    Object? singleMapObjects = null,
    Object? mainMapObjects = null,
    Object? distanceInKm = null,
    Object? travelTime = null,
    Object? hasLocationPermission = null,
    Object? userLocation = freezed,
    Object? errorMessage = null,
  }) {
    return _then(_$MapStateImpl(
      getLocationStatus: null == getLocationStatus
          ? _value.getLocationStatus
          : getLocationStatus // ignore: cast_nullable_to_non_nullable
              as FormzSubmissionStatus,
      permissionStatus: null == permissionStatus
          ? _value.permissionStatus
          : permissionStatus // ignore: cast_nullable_to_non_nullable
              as LocationPermission,
      singleMapObjects: null == singleMapObjects
          ? _value._singleMapObjects
          : singleMapObjects // ignore: cast_nullable_to_non_nullable
              as List<MapObject>,
      mainMapObjects: null == mainMapObjects
          ? _value._mainMapObjects
          : mainMapObjects // ignore: cast_nullable_to_non_nullable
              as List<MapObject>,
      distanceInKm: null == distanceInKm
          ? _value.distanceInKm
          : distanceInKm // ignore: cast_nullable_to_non_nullable
              as double,
      travelTime: null == travelTime
          ? _value.travelTime
          : travelTime // ignore: cast_nullable_to_non_nullable
              as String,
      hasLocationPermission: null == hasLocationPermission
          ? _value.hasLocationPermission
          : hasLocationPermission // ignore: cast_nullable_to_non_nullable
              as bool,
      userLocation: freezed == userLocation
          ? _value.userLocation
          : userLocation // ignore: cast_nullable_to_non_nullable
              as Point?,
      errorMessage: null == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MapStateImpl extends _MapState {
  const _$MapStateImpl(
      {this.getLocationStatus = FormzSubmissionStatus.initial,
      this.permissionStatus = LocationPermission.whileInUse,
      final List<MapObject> singleMapObjects = const [],
      final List<MapObject> mainMapObjects = const [],
      this.distanceInKm = 0,
      this.travelTime = '',
      this.hasLocationPermission = false,
      this.userLocation,
      this.errorMessage = ''})
      : _singleMapObjects = singleMapObjects,
        _mainMapObjects = mainMapObjects,
        super._();

  @override
  @JsonKey()
  final FormzSubmissionStatus getLocationStatus;
  @override
  @JsonKey()
  final LocationPermission permissionStatus;
  final List<MapObject> _singleMapObjects;
  @override
  @JsonKey()
  List<MapObject> get singleMapObjects {
    if (_singleMapObjects is EqualUnmodifiableListView)
      return _singleMapObjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_singleMapObjects);
  }

  final List<MapObject> _mainMapObjects;
  @override
  @JsonKey()
  List<MapObject> get mainMapObjects {
    if (_mainMapObjects is EqualUnmodifiableListView) return _mainMapObjects;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mainMapObjects);
  }

  @override
  @JsonKey()
  final double distanceInKm;
  @override
  @JsonKey()
  final String travelTime;
  @override
  @JsonKey()
  final bool hasLocationPermission;
  @override
  final Point? userLocation;
  @override
  @JsonKey()
  final String errorMessage;

  @override
  String toString() {
    return 'MapState(getLocationStatus: $getLocationStatus, permissionStatus: $permissionStatus, singleMapObjects: $singleMapObjects, mainMapObjects: $mainMapObjects, distanceInKm: $distanceInKm, travelTime: $travelTime, hasLocationPermission: $hasLocationPermission, userLocation: $userLocation, errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MapStateImpl &&
            (identical(other.getLocationStatus, getLocationStatus) ||
                other.getLocationStatus == getLocationStatus) &&
            (identical(other.permissionStatus, permissionStatus) ||
                other.permissionStatus == permissionStatus) &&
            const DeepCollectionEquality()
                .equals(other._singleMapObjects, _singleMapObjects) &&
            const DeepCollectionEquality()
                .equals(other._mainMapObjects, _mainMapObjects) &&
            (identical(other.distanceInKm, distanceInKm) ||
                other.distanceInKm == distanceInKm) &&
            (identical(other.travelTime, travelTime) ||
                other.travelTime == travelTime) &&
            (identical(other.hasLocationPermission, hasLocationPermission) ||
                other.hasLocationPermission == hasLocationPermission) &&
            (identical(other.userLocation, userLocation) ||
                other.userLocation == userLocation) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      getLocationStatus,
      permissionStatus,
      const DeepCollectionEquality().hash(_singleMapObjects),
      const DeepCollectionEquality().hash(_mainMapObjects),
      distanceInKm,
      travelTime,
      hasLocationPermission,
      userLocation,
      errorMessage);

  /// Create a copy of MapState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MapStateImplCopyWith<_$MapStateImpl> get copyWith =>
      __$$MapStateImplCopyWithImpl<_$MapStateImpl>(this, _$identity);
}

abstract class _MapState extends MapState {
  const factory _MapState(
      {final FormzSubmissionStatus getLocationStatus,
      final LocationPermission permissionStatus,
      final List<MapObject> singleMapObjects,
      final List<MapObject> mainMapObjects,
      final double distanceInKm,
      final String travelTime,
      final bool hasLocationPermission,
      final Point? userLocation,
      final String errorMessage}) = _$MapStateImpl;
  const _MapState._() : super._();

  @override
  FormzSubmissionStatus get getLocationStatus;
  @override
  LocationPermission get permissionStatus;
  @override
  List<MapObject> get singleMapObjects;
  @override
  List<MapObject> get mainMapObjects;
  @override
  double get distanceInKm;
  @override
  String get travelTime;
  @override
  bool get hasLocationPermission;
  @override
  Point? get userLocation;
  @override
  String get errorMessage;

  /// Create a copy of MapState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MapStateImplCopyWith<_$MapStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
