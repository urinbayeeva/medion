// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'branch_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BranchEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchBranches,
    required TResult Function() fetchAwards,
    required TResult Function() fetchStudy,
    required TResult Function() fetchOfferta,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchBranches,
    TResult? Function()? fetchAwards,
    TResult? Function()? fetchStudy,
    TResult? Function()? fetchOfferta,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchBranches,
    TResult Function()? fetchAwards,
    TResult Function()? fetchStudy,
    TResult Function()? fetchOfferta,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchBranches value) fetchBranches,
    required TResult Function(_FetchAwards value) fetchAwards,
    required TResult Function(_FetchStudy value) fetchStudy,
    required TResult Function(_FetchOfferta value) fetchOfferta,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchBranches value)? fetchBranches,
    TResult? Function(_FetchAwards value)? fetchAwards,
    TResult? Function(_FetchStudy value)? fetchStudy,
    TResult? Function(_FetchOfferta value)? fetchOfferta,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchBranches value)? fetchBranches,
    TResult Function(_FetchAwards value)? fetchAwards,
    TResult Function(_FetchStudy value)? fetchStudy,
    TResult Function(_FetchOfferta value)? fetchOfferta,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BranchEventCopyWith<$Res> {
  factory $BranchEventCopyWith(
          BranchEvent value, $Res Function(BranchEvent) then) =
      _$BranchEventCopyWithImpl<$Res, BranchEvent>;
}

/// @nodoc
class _$BranchEventCopyWithImpl<$Res, $Val extends BranchEvent>
    implements $BranchEventCopyWith<$Res> {
  _$BranchEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BranchEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$FetchBranchesImplCopyWith<$Res> {
  factory _$$FetchBranchesImplCopyWith(
          _$FetchBranchesImpl value, $Res Function(_$FetchBranchesImpl) then) =
      __$$FetchBranchesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchBranchesImplCopyWithImpl<$Res>
    extends _$BranchEventCopyWithImpl<$Res, _$FetchBranchesImpl>
    implements _$$FetchBranchesImplCopyWith<$Res> {
  __$$FetchBranchesImplCopyWithImpl(
      _$FetchBranchesImpl _value, $Res Function(_$FetchBranchesImpl) _then)
      : super(_value, _then);

  /// Create a copy of BranchEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchBranchesImpl implements _FetchBranches {
  const _$FetchBranchesImpl();

  @override
  String toString() {
    return 'BranchEvent.fetchBranches()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchBranchesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchBranches,
    required TResult Function() fetchAwards,
    required TResult Function() fetchStudy,
    required TResult Function() fetchOfferta,
  }) {
    return fetchBranches();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchBranches,
    TResult? Function()? fetchAwards,
    TResult? Function()? fetchStudy,
    TResult? Function()? fetchOfferta,
  }) {
    return fetchBranches?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchBranches,
    TResult Function()? fetchAwards,
    TResult Function()? fetchStudy,
    TResult Function()? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchBranches != null) {
      return fetchBranches();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchBranches value) fetchBranches,
    required TResult Function(_FetchAwards value) fetchAwards,
    required TResult Function(_FetchStudy value) fetchStudy,
    required TResult Function(_FetchOfferta value) fetchOfferta,
  }) {
    return fetchBranches(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchBranches value)? fetchBranches,
    TResult? Function(_FetchAwards value)? fetchAwards,
    TResult? Function(_FetchStudy value)? fetchStudy,
    TResult? Function(_FetchOfferta value)? fetchOfferta,
  }) {
    return fetchBranches?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchBranches value)? fetchBranches,
    TResult Function(_FetchAwards value)? fetchAwards,
    TResult Function(_FetchStudy value)? fetchStudy,
    TResult Function(_FetchOfferta value)? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchBranches != null) {
      return fetchBranches(this);
    }
    return orElse();
  }
}

abstract class _FetchBranches implements BranchEvent {
  const factory _FetchBranches() = _$FetchBranchesImpl;
}

/// @nodoc
abstract class _$$FetchAwardsImplCopyWith<$Res> {
  factory _$$FetchAwardsImplCopyWith(
          _$FetchAwardsImpl value, $Res Function(_$FetchAwardsImpl) then) =
      __$$FetchAwardsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchAwardsImplCopyWithImpl<$Res>
    extends _$BranchEventCopyWithImpl<$Res, _$FetchAwardsImpl>
    implements _$$FetchAwardsImplCopyWith<$Res> {
  __$$FetchAwardsImplCopyWithImpl(
      _$FetchAwardsImpl _value, $Res Function(_$FetchAwardsImpl) _then)
      : super(_value, _then);

  /// Create a copy of BranchEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchAwardsImpl implements _FetchAwards {
  const _$FetchAwardsImpl();

  @override
  String toString() {
    return 'BranchEvent.fetchAwards()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchAwardsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchBranches,
    required TResult Function() fetchAwards,
    required TResult Function() fetchStudy,
    required TResult Function() fetchOfferta,
  }) {
    return fetchAwards();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchBranches,
    TResult? Function()? fetchAwards,
    TResult? Function()? fetchStudy,
    TResult? Function()? fetchOfferta,
  }) {
    return fetchAwards?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchBranches,
    TResult Function()? fetchAwards,
    TResult Function()? fetchStudy,
    TResult Function()? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchAwards != null) {
      return fetchAwards();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchBranches value) fetchBranches,
    required TResult Function(_FetchAwards value) fetchAwards,
    required TResult Function(_FetchStudy value) fetchStudy,
    required TResult Function(_FetchOfferta value) fetchOfferta,
  }) {
    return fetchAwards(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchBranches value)? fetchBranches,
    TResult? Function(_FetchAwards value)? fetchAwards,
    TResult? Function(_FetchStudy value)? fetchStudy,
    TResult? Function(_FetchOfferta value)? fetchOfferta,
  }) {
    return fetchAwards?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchBranches value)? fetchBranches,
    TResult Function(_FetchAwards value)? fetchAwards,
    TResult Function(_FetchStudy value)? fetchStudy,
    TResult Function(_FetchOfferta value)? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchAwards != null) {
      return fetchAwards(this);
    }
    return orElse();
  }
}

abstract class _FetchAwards implements BranchEvent {
  const factory _FetchAwards() = _$FetchAwardsImpl;
}

/// @nodoc
abstract class _$$FetchStudyImplCopyWith<$Res> {
  factory _$$FetchStudyImplCopyWith(
          _$FetchStudyImpl value, $Res Function(_$FetchStudyImpl) then) =
      __$$FetchStudyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchStudyImplCopyWithImpl<$Res>
    extends _$BranchEventCopyWithImpl<$Res, _$FetchStudyImpl>
    implements _$$FetchStudyImplCopyWith<$Res> {
  __$$FetchStudyImplCopyWithImpl(
      _$FetchStudyImpl _value, $Res Function(_$FetchStudyImpl) _then)
      : super(_value, _then);

  /// Create a copy of BranchEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchStudyImpl implements _FetchStudy {
  const _$FetchStudyImpl();

  @override
  String toString() {
    return 'BranchEvent.fetchStudy()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchStudyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchBranches,
    required TResult Function() fetchAwards,
    required TResult Function() fetchStudy,
    required TResult Function() fetchOfferta,
  }) {
    return fetchStudy();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchBranches,
    TResult? Function()? fetchAwards,
    TResult? Function()? fetchStudy,
    TResult? Function()? fetchOfferta,
  }) {
    return fetchStudy?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchBranches,
    TResult Function()? fetchAwards,
    TResult Function()? fetchStudy,
    TResult Function()? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchStudy != null) {
      return fetchStudy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchBranches value) fetchBranches,
    required TResult Function(_FetchAwards value) fetchAwards,
    required TResult Function(_FetchStudy value) fetchStudy,
    required TResult Function(_FetchOfferta value) fetchOfferta,
  }) {
    return fetchStudy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchBranches value)? fetchBranches,
    TResult? Function(_FetchAwards value)? fetchAwards,
    TResult? Function(_FetchStudy value)? fetchStudy,
    TResult? Function(_FetchOfferta value)? fetchOfferta,
  }) {
    return fetchStudy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchBranches value)? fetchBranches,
    TResult Function(_FetchAwards value)? fetchAwards,
    TResult Function(_FetchStudy value)? fetchStudy,
    TResult Function(_FetchOfferta value)? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchStudy != null) {
      return fetchStudy(this);
    }
    return orElse();
  }
}

abstract class _FetchStudy implements BranchEvent {
  const factory _FetchStudy() = _$FetchStudyImpl;
}

/// @nodoc
abstract class _$$FetchOffertaImplCopyWith<$Res> {
  factory _$$FetchOffertaImplCopyWith(
          _$FetchOffertaImpl value, $Res Function(_$FetchOffertaImpl) then) =
      __$$FetchOffertaImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchOffertaImplCopyWithImpl<$Res>
    extends _$BranchEventCopyWithImpl<$Res, _$FetchOffertaImpl>
    implements _$$FetchOffertaImplCopyWith<$Res> {
  __$$FetchOffertaImplCopyWithImpl(
      _$FetchOffertaImpl _value, $Res Function(_$FetchOffertaImpl) _then)
      : super(_value, _then);

  /// Create a copy of BranchEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchOffertaImpl implements _FetchOfferta {
  const _$FetchOffertaImpl();

  @override
  String toString() {
    return 'BranchEvent.fetchOfferta()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchOffertaImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchBranches,
    required TResult Function() fetchAwards,
    required TResult Function() fetchStudy,
    required TResult Function() fetchOfferta,
  }) {
    return fetchOfferta();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchBranches,
    TResult? Function()? fetchAwards,
    TResult? Function()? fetchStudy,
    TResult? Function()? fetchOfferta,
  }) {
    return fetchOfferta?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchBranches,
    TResult Function()? fetchAwards,
    TResult Function()? fetchStudy,
    TResult Function()? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchOfferta != null) {
      return fetchOfferta();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FetchBranches value) fetchBranches,
    required TResult Function(_FetchAwards value) fetchAwards,
    required TResult Function(_FetchStudy value) fetchStudy,
    required TResult Function(_FetchOfferta value) fetchOfferta,
  }) {
    return fetchOfferta(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FetchBranches value)? fetchBranches,
    TResult? Function(_FetchAwards value)? fetchAwards,
    TResult? Function(_FetchStudy value)? fetchStudy,
    TResult? Function(_FetchOfferta value)? fetchOfferta,
  }) {
    return fetchOfferta?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FetchBranches value)? fetchBranches,
    TResult Function(_FetchAwards value)? fetchAwards,
    TResult Function(_FetchStudy value)? fetchStudy,
    TResult Function(_FetchOfferta value)? fetchOfferta,
    required TResult orElse(),
  }) {
    if (fetchOfferta != null) {
      return fetchOfferta(this);
    }
    return orElse();
  }
}

abstract class _FetchOfferta implements BranchEvent {
  const factory _FetchOfferta() = _$FetchOffertaImpl;
}

/// @nodoc
mixin _$BranchState {
  bool get loading => throw _privateConstructorUsedError;
  bool get error => throw _privateConstructorUsedError;
  bool get success => throw _privateConstructorUsedError;
  List<BranchModel> get branches => throw _privateConstructorUsedError;
  List<AwardsModel> get awards => throw _privateConstructorUsedError;
  EducationModel? get study => throw _privateConstructorUsedError;
  OfferModel? get offerta => throw _privateConstructorUsedError;

  /// Create a copy of BranchState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BranchStateCopyWith<BranchState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BranchStateCopyWith<$Res> {
  factory $BranchStateCopyWith(
          BranchState value, $Res Function(BranchState) then) =
      _$BranchStateCopyWithImpl<$Res, BranchState>;
  @useResult
  $Res call(
      {bool loading,
      bool error,
      bool success,
      List<BranchModel> branches,
      List<AwardsModel> awards,
      EducationModel? study,
      OfferModel? offerta});
}

/// @nodoc
class _$BranchStateCopyWithImpl<$Res, $Val extends BranchState>
    implements $BranchStateCopyWith<$Res> {
  _$BranchStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BranchState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? error = null,
    Object? success = null,
    Object? branches = null,
    Object? awards = null,
    Object? study = freezed,
    Object? offerta = freezed,
  }) {
    return _then(_value.copyWith(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as bool,
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      branches: null == branches
          ? _value.branches
          : branches // ignore: cast_nullable_to_non_nullable
              as List<BranchModel>,
      awards: null == awards
          ? _value.awards
          : awards // ignore: cast_nullable_to_non_nullable
              as List<AwardsModel>,
      study: freezed == study
          ? _value.study
          : study // ignore: cast_nullable_to_non_nullable
              as EducationModel?,
      offerta: freezed == offerta
          ? _value.offerta
          : offerta // ignore: cast_nullable_to_non_nullable
              as OfferModel?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BranchStateImplCopyWith<$Res>
    implements $BranchStateCopyWith<$Res> {
  factory _$$BranchStateImplCopyWith(
          _$BranchStateImpl value, $Res Function(_$BranchStateImpl) then) =
      __$$BranchStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool loading,
      bool error,
      bool success,
      List<BranchModel> branches,
      List<AwardsModel> awards,
      EducationModel? study,
      OfferModel? offerta});
}

/// @nodoc
class __$$BranchStateImplCopyWithImpl<$Res>
    extends _$BranchStateCopyWithImpl<$Res, _$BranchStateImpl>
    implements _$$BranchStateImplCopyWith<$Res> {
  __$$BranchStateImplCopyWithImpl(
      _$BranchStateImpl _value, $Res Function(_$BranchStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of BranchState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? error = null,
    Object? success = null,
    Object? branches = null,
    Object? awards = null,
    Object? study = freezed,
    Object? offerta = freezed,
  }) {
    return _then(_$BranchStateImpl(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as bool,
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      branches: null == branches
          ? _value._branches
          : branches // ignore: cast_nullable_to_non_nullable
              as List<BranchModel>,
      awards: null == awards
          ? _value._awards
          : awards // ignore: cast_nullable_to_non_nullable
              as List<AwardsModel>,
      study: freezed == study
          ? _value.study
          : study // ignore: cast_nullable_to_non_nullable
              as EducationModel?,
      offerta: freezed == offerta
          ? _value.offerta
          : offerta // ignore: cast_nullable_to_non_nullable
              as OfferModel?,
    ));
  }
}

/// @nodoc

class _$BranchStateImpl extends _BranchState {
  const _$BranchStateImpl(
      {this.loading = false,
      this.error = false,
      this.success = false,
      final List<BranchModel> branches = const [],
      final List<AwardsModel> awards = const [],
      this.study = null,
      this.offerta = null})
      : _branches = branches,
        _awards = awards,
        super._();

  @override
  @JsonKey()
  final bool loading;
  @override
  @JsonKey()
  final bool error;
  @override
  @JsonKey()
  final bool success;
  final List<BranchModel> _branches;
  @override
  @JsonKey()
  List<BranchModel> get branches {
    if (_branches is EqualUnmodifiableListView) return _branches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_branches);
  }

  final List<AwardsModel> _awards;
  @override
  @JsonKey()
  List<AwardsModel> get awards {
    if (_awards is EqualUnmodifiableListView) return _awards;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_awards);
  }

  @override
  @JsonKey()
  final EducationModel? study;
  @override
  @JsonKey()
  final OfferModel? offerta;

  @override
  String toString() {
    return 'BranchState(loading: $loading, error: $error, success: $success, branches: $branches, awards: $awards, study: $study, offerta: $offerta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BranchStateImpl &&
            (identical(other.loading, loading) || other.loading == loading) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.success, success) || other.success == success) &&
            const DeepCollectionEquality().equals(other._branches, _branches) &&
            const DeepCollectionEquality().equals(other._awards, _awards) &&
            (identical(other.study, study) || other.study == study) &&
            (identical(other.offerta, offerta) || other.offerta == offerta));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      loading,
      error,
      success,
      const DeepCollectionEquality().hash(_branches),
      const DeepCollectionEquality().hash(_awards),
      study,
      offerta);

  /// Create a copy of BranchState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BranchStateImplCopyWith<_$BranchStateImpl> get copyWith =>
      __$$BranchStateImplCopyWithImpl<_$BranchStateImpl>(this, _$identity);
}

abstract class _BranchState extends BranchState {
  const factory _BranchState(
      {final bool loading,
      final bool error,
      final bool success,
      final List<BranchModel> branches,
      final List<AwardsModel> awards,
      final EducationModel? study,
      final OfferModel? offerta}) = _$BranchStateImpl;
  const _BranchState._() : super._();

  @override
  bool get loading;
  @override
  bool get error;
  @override
  bool get success;
  @override
  List<BranchModel> get branches;
  @override
  List<AwardsModel> get awards;
  @override
  EducationModel? get study;
  @override
  OfferModel? get offerta;

  /// Create a copy of BranchState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BranchStateImplCopyWith<_$BranchStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
